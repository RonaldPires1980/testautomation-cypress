"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeHandler = void 0;
const http_1 = require("http");
const https_1 = require("https");
const ws_1 = require("ws");
const fs_1 = __importDefault(require("fs"));
const { name, version } = require('../package.json');
const TOKEN_HEADER = 'x-eyes-universal-token';
const TOKEN = `${name}@${version}`;
async function makeHandler({ port = 21077, singleton = true, lazy = false, debug = false, cert, key, } = {}) {
    if (cert)
        cert = fs_1.default.readFileSync(cert);
    if (key)
        key = fs_1.default.readFileSync(key);
    const secure = Boolean(cert && key);
    const http = secure ? new https_1.Server({ cert, key }) : new http_1.Server();
    http.on('request', (request, response) => {
        if (request.url === '/handshake') {
            const token = debug ? request.headers[TOKEN_HEADER] : TOKEN;
            if (request.headers[TOKEN_HEADER] === token) {
                response.writeHead(200, { [TOKEN_HEADER]: token });
            }
            else {
                response.writeHead(400);
            }
            response.end();
        }
    });
    http.listen(port, 'localhost');
    return new Promise((resolve, reject) => {
        http.on('listening', () => {
            const ws = new ws_1.Server({ server: http, path: '/eyes', maxPayload: 256 * 1024 * 1024 });
            ws.on('close', () => http.close());
            resolve({ server: ws, port });
        });
        http.on('error', async (err) => {
            if (!lazy && err.code === 'EADDRINUSE') {
                if (singleton && (await isHandshakable({ port, secure }))) {
                    return resolve({ port });
                }
                else {
                    return resolve(await makeHandler({ port: port + 1, singleton }));
                }
            }
            reject(err);
        });
    });
}
exports.makeHandler = makeHandler;
async function isHandshakable({ port, secure }) {
    const request = secure ? https_1.request : http_1.request;
    return new Promise(resolve => {
        const handshake = request(`${secure ? 'https' : 'http'}://localhost:${port}/handshake`, {
            headers: { [TOKEN_HEADER]: TOKEN },
        });
        handshake.on('response', ({ statusCode, headers }) => {
            resolve(statusCode === 200 && headers[TOKEN_HEADER] === TOKEN);
        });
        handshake.on('error', () => resolve(false));
        handshake.end();
    });
}
