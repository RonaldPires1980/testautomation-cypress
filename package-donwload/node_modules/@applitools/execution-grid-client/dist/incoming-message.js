"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyIncomingMessage = void 0;
function modifyIncomingMessage(message) {
    let buffer;
    const modifiedMessage = Object.create(message);
    modifiedMessage.body = async function body() {
        buffer !== null && buffer !== void 0 ? buffer : (buffer = readStream(message));
        return buffer;
    };
    modifiedMessage.json = async function json() {
        try {
            buffer !== null && buffer !== void 0 ? buffer : (buffer = readStream(message));
            return JSON.parse((await buffer).toString('utf8'));
        }
        catch (_a) {
            return null;
        }
    };
    modifiedMessage.pipe = function pipe(destination, options) {
        if (!buffer) {
            buffer = readStream(message);
            return message.pipe(destination, options);
        }
        buffer.then(buffer => {
            destination.write(buffer);
            if ((options === null || options === void 0 ? void 0 : options.end) !== false)
                destination.end();
        });
        return destination;
    };
    return modifiedMessage;
    function readStream(message) {
        return new Promise((resolve, reject) => {
            let ended = false;
            const chunks = [];
            message.on('data', onData);
            message.on('end', onEnd);
            message.on('error', onEnd);
            message.on('aborted', onAbort);
            message.on('close', onCleanup);
            function onData(chunk) {
                chunks.push(chunk);
            }
            function onEnd(err) {
                if (err)
                    return reject(err);
                ended = true;
                resolve(Buffer.concat(chunks));
            }
            function onAbort() {
                if (!ended)
                    reject(new Error('Cannot collect message data due to it being closed before ended'));
            }
            function onCleanup() {
                message.off('data', onData);
                message.off('end', onEnd);
                message.off('error', onEnd);
                message.off('aborted', onAbort);
                message.off('close', onCleanup);
            }
        });
    }
}
exports.modifyIncomingMessage = modifyIncomingMessage;
