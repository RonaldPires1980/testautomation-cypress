"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeServer = void 0;
const http_1 = require("http");
const logger_1 = require("@applitools/logger");
const queue_1 = require("./queue");
const tunnel_1 = require("./tunnel");
const proxy_1 = require("./proxy");
const incoming_message_1 = require("./incoming-message");
const utils = __importStar(require("@applitools/utils"));
const RETRY_BACKOFF = [].concat(Array(5).fill(2000), // 5 tries with delay 2s (total 10s)
Array(4).fill(5000), // 4 tries with delay 5s (total 20s)
10000);
const RETRY_ERROR_CODES = ['CONCURRENCY_LIMIT_REACHED', 'NO_AVAILABLE_DRIVER_POD'];
function makeServer({ egServerUrl = 'https://exec-wus.applitools.com', egTunnelUrl = process.env.APPLITOOLS_EG_TUNNEL_URL, egTimeout = process.env.APPLITOOLS_EG_TIMEOUT, egInactivityTimeout = process.env.APPLITOOLS_EG_INACTIVITY_TIMEOUT, proxyUrl = process.env.APPLITOOLS_PROXY, eyesServerUrl = process.env.APPLITOOLS_SERVER_URL, apiKey = process.env.APPLITOOLS_API_KEY, port = 0, resolveUrls = true, logger, } = {}) {
    logger = logger ? logger.extend({ label: 'eg-client' }) : (0, logger_1.makeLogger)({ label: 'eg-client', colors: true });
    const proxyRequest = (0, proxy_1.makeProxy)({
        url: egServerUrl,
        resolveUrls,
        proxy: proxyUrl,
        shouldRetry: async (proxyResponse) => {
            return proxyResponse.statusCode >= 500 && !utils.types.has(await proxyResponse.json(), 'value');
        },
    });
    const { createTunnel, deleteTunnel } = (0, tunnel_1.makeTunnelManager)({ egTunnelUrl, logger });
    const sessions = new Map();
    const queues = new Map();
    const server = (0, http_1.createServer)(async (message, response) => {
        const request = (0, incoming_message_1.modifyIncomingMessage)(message);
        const requestLogger = logger.extend({
            tags: { request: `[${request.method}] ${request.url}`, requestId: utils.general.guid() },
        });
        try {
            if (request.method === 'POST' && /^\/session\/?$/.test(request.url)) {
                return await createSession({ request, response, logger: requestLogger });
            }
            else if (request.method === 'DELETE' && /^\/session\/[^\/]+\/?$/.test(request.url)) {
                return await deleteSession({ request, response, logger: requestLogger });
            }
            else {
                requestLogger.log('Passthrough request');
                return await proxyRequest({ request, response, logger: requestLogger });
            }
        }
        catch (err) {
            // console.error(err)
            requestLogger.error(`Error during processing request:`, err);
            if (!response.writableEnded) {
                response
                    .writeHead(500)
                    .end(JSON.stringify({ value: { error: 'internal proxy server error', message: err.message, stacktrace: '' } }));
            }
        }
        finally {
            requestLogger.log(`Request was responded with status ${response.statusCode}`);
        }
    });
    server.listen(port);
    return new Promise((resolve, reject) => {
        server.on('listening', () => {
            const address = server.address();
            logger.log(`Proxy server has started on port ${address.port}`);
            resolve({ url: `http://localhost:${address.port}`, port: address.port, server });
        });
        server.on('error', async (err) => {
            logger.fatal('Error starting proxy server', err);
            reject(err);
        });
    });
    async function createSession({ request, response, logger, }) {
        var _a, _b, _c, _d, _e, _f;
        const requestBody = await request.json();
        logger.log(`Request was intercepted with body:`, requestBody);
        const session = {};
        session.eyesServerUrl = (_a = extractCapability(requestBody, 'applitools:eyesServerUrl')) !== null && _a !== void 0 ? _a : eyesServerUrl;
        session.apiKey = (_b = extractCapability(requestBody, 'applitools:apiKey')) !== null && _b !== void 0 ? _b : apiKey;
        session.tunnelId = extractCapability(requestBody, 'applitools:tunnel') ? await createTunnel(session) : undefined;
        session.key = `${(_c = session.eyesServerUrl) !== null && _c !== void 0 ? _c : 'default'}:${session.apiKey}`;
        const applitoolsCapabilities = {
            'applitools:eyesServerUrl': session.eyesServerUrl,
            'applitools:apiKey': session.apiKey,
            'applitools:x-tunnel-id-0': session.tunnelId,
            'applitools:timeout': (_d = extractCapability(requestBody, 'applitools:timeout')) !== null && _d !== void 0 ? _d : egTimeout,
            'applitools:inactivityTimeout': (_e = extractCapability(requestBody, 'applitools:inactivityTimeout')) !== null && _e !== void 0 ? _e : egInactivityTimeout,
        };
        if (requestBody.capabilities) {
            requestBody.capabilities.alwaysMatch = Object.assign(Object.assign({}, (_f = requestBody.capabilities) === null || _f === void 0 ? void 0 : _f.alwaysMatch), applitoolsCapabilities);
        }
        if (requestBody.desiredCapabilities) {
            requestBody.desiredCapabilities = Object.assign(Object.assign({}, requestBody.desiredCapabilities), applitoolsCapabilities);
        }
        logger.log('Request body has modified:', requestBody);
        let queue = queues.get(session.key);
        if (!queue) {
            queue = (0, queue_1.makeQueue)({ logger: logger.extend({ tags: { queue: session.key } }) });
            queues.set(session.key, queue);
        }
        request.socket.on('close', () => queue.cancel(task));
        await queue.run(task);
        async function task(signal, attempt = 1) {
            var _a, _b, _c;
            // do not start the task if it is already aborted
            if (signal.aborted)
                return;
            const proxyResponse = await proxyRequest({
                request,
                response,
                options: { body: JSON.stringify(requestBody), handle: false, signal },
                logger,
            });
            const responseBody = await proxyResponse.json();
            logger.log(`Response was intercepted with body:`, responseBody);
            if (RETRY_ERROR_CODES.includes((_b = (_a = responseBody.value) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.appliErrorCode)) {
                queue.cork();
                // after query is corked the task might be aborted
                if (signal.aborted)
                    return;
                await utils.general.sleep(RETRY_BACKOFF[Math.min(attempt, RETRY_BACKOFF.length - 1)]);
                logger.log(`Attempt (${attempt}) to create session was failed with applitools status code:`, responseBody.value.data.appliErrorCode);
                return task(signal, attempt + 1);
            }
            else {
                queue.uncork();
                if ((_c = responseBody.value) === null || _c === void 0 ? void 0 : _c.sessionId)
                    sessions.set(responseBody.value.sessionId, session);
                proxyResponse.pipe(response);
                return;
            }
        }
    }
    async function deleteSession({ request, response, logger, }) {
        const sessionId = request.url.split('/').pop();
        logger.log(`Request was intercepted with sessionId:`, sessionId);
        await proxyRequest({ request, response, logger });
        const session = sessions.get(sessionId);
        if (session.tunnelId) {
            await deleteTunnel(session);
            logger.log(`Tunnel with id ${session.tunnelId} was deleted for session with id ${sessionId}`);
        }
        sessions.delete(sessionId);
    }
    function extractCapability(data, capabilityName) {
        var _a, _b, _c, _d;
        return (_c = (_b = (_a = data.capabilities) === null || _a === void 0 ? void 0 : _a.alwaysMatch) === null || _b === void 0 ? void 0 : _b[capabilityName]) !== null && _c !== void 0 ? _c : (_d = data.desiredCapabilities) === null || _d === void 0 ? void 0 : _d[capabilityName];
    }
}
exports.makeServer = makeServer;
