import type * as types from '@applitools/types';
import { type Logger } from '@applitools/logger';
import { type Context } from './context';
export declare type ElementState<TElement> = {
    contentSize?: types.Size;
    scrollOffset?: types.Location;
    transforms?: any;
    attributes?: Record<string, string | Error>;
    touchPadding?: number;
    containedElements?: Map<TElement, boolean>;
};
export declare class Element<TDriver, TContext, TElement, TSelector> {
    private _target;
    private _context;
    private _selector;
    private _commonSelector?;
    private _index;
    private _state;
    private _originalOverflow;
    private _logger;
    protected readonly _spec: types.SpecDriver<TDriver, TContext, TElement, TSelector>;
    constructor(options: {
        spec: types.SpecDriver<TDriver, TContext, TElement, TSelector>;
        element?: TElement | Element<TDriver, TContext, TElement, TSelector>;
        context?: Context<TDriver, TContext, TElement, TSelector>;
        selector?: types.Selector<TSelector>;
        index?: number;
        logger?: Logger;
    });
    get target(): TElement;
    get selector(): types.Selector<TSelector>;
    get commonSelector(): types.Selector<never>;
    get index(): number;
    get context(): Context<TDriver, TContext, TElement, TSelector>;
    get driver(): import("./driver").Driver<TDriver, TContext, TElement, TSelector>;
    get isRef(): boolean;
    equals(element: Element<TDriver, TContext, TElement, TSelector> | TElement): Promise<boolean>;
    contains(innerElement: Element<TDriver, TContext, TElement, TSelector> | TElement): Promise<boolean>;
    init(context: Context<TDriver, TContext, TElement, TSelector>): Promise<this>;
    getRegion(): Promise<types.Region>;
    getClientRegion(): Promise<types.Region>;
    getContentSize(): Promise<types.Size>;
    isPager(): Promise<boolean>;
    isScrollable(): Promise<boolean>;
    isRoot(): Promise<boolean>;
    getShadowRoot(): Promise<TElement>;
    getTouchPadding(): Promise<number>;
    getText(): Promise<string>;
    getAttribute(name: string): Promise<string>;
    setAttribute(name: string, value: string): Promise<void>;
    scrollTo(offset: types.Location, options?: {
        force: boolean;
    }): Promise<types.Location>;
    translateTo(offset: types.Location): Promise<types.Location>;
    getScrollOffset(): Promise<types.Location>;
    getTranslateOffset(): Promise<types.Location>;
    getInnerOffset(): Promise<types.Location>;
    click(): Promise<void>;
    type(value: string): Promise<void>;
    preserveState(): Promise<ElementState<TElement>>;
    restoreState(state?: ElementState<TElement>): Promise<void>;
    hideScrollbars(): Promise<void>;
    restoreScrollbars(): Promise<void>;
    refresh(freshElement?: TElement): Promise<boolean>;
    withRefresh<TResult>(operation: (...args: any[]) => TResult): Promise<TResult>;
    toJSON(): TElement;
}
