import type * as types from '@applitools/types';
import { type Logger } from '@applitools/logger';
import { type Driver } from './driver';
import { Element } from './element';
export declare type ContextReference<TDriver, TContext, TElement, TSelector> = Context<TDriver, TContext, TElement, TSelector> | Element<TDriver, TContext, TElement, TSelector> | TElement | types.Selector<TSelector> | string | number;
export declare type ContextPlain<TDriver, TContext, TElement, TSelector> = ContextReference<TDriver, TContext, TElement, TSelector> | {
    reference: ContextReference<TDriver, TContext, TElement, TSelector>;
    scrollingElement?: Element<TDriver, TContext, TElement, TSelector>;
    parent?: ContextPlain<TDriver, TContext, TElement, TSelector>;
};
export declare type ContextState = {
    region?: types.Region;
    clientRegion?: types.Region;
    scrollingRegion?: types.Region;
    innerOffset?: types.Location;
};
export declare class Context<TDriver, TContext, TElement, TSelector> {
    private _target;
    private _driver;
    private _parent;
    private _element;
    private _reference;
    private _scrollingElement;
    private _state;
    private _logger;
    private _isReference;
    protected readonly _spec: types.SpecDriver<TDriver, TContext, TElement, TSelector>;
    constructor(options: {
        spec: types.SpecDriver<TDriver, TContext, TElement, TSelector>;
        context?: TContext | Context<TDriver, TContext, TElement, TSelector>;
        driver?: Driver<TDriver, TContext, TElement, TSelector>;
        parent?: Context<TDriver, TContext, TElement, TSelector>;
        reference?: ContextReference<TDriver, TContext, TElement, TSelector>;
        element?: Element<TDriver, TContext, TElement, TSelector>;
        scrollingElement?: Element<TDriver, TContext, TElement, TSelector>;
        logger?: Logger;
    });
    get target(): TContext;
    get driver(): Driver<TDriver, TContext, TElement, TSelector>;
    get parent(): Context<TDriver, TContext, TElement, TSelector> | null;
    get main(): Context<TDriver, TContext, TElement, TSelector>;
    get path(): Context<TDriver, TContext, TElement, TSelector>[];
    get isMain(): boolean;
    get isCurrent(): boolean;
    get isInitialized(): boolean;
    get isRef(): boolean;
    init(): Promise<this>;
    focus(): Promise<this>;
    equals(context: Context<TDriver, TContext, TElement, TSelector> | Element<TDriver, TContext, TElement, TSelector>): Promise<boolean>;
    context(reference: ContextPlain<TDriver, TContext, TElement, TSelector>): Promise<Context<TDriver, TContext, TElement, TSelector>>;
    root(selector: types.Selector<TSelector>): Promise<{
        context: Context<TDriver, TContext, TElement, TSelector>;
        shadow?: Element<TDriver, TContext, TElement, TSelector>;
        selector: types.Selector<TSelector>;
    }>;
    element(elementOrSelector: TElement | types.Selector<TSelector>): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    elements(elementOrSelector: TElement | types.Selector<TSelector>): Promise<Element<TDriver, TContext, TElement, TSelector>[]>;
    waitFor(selector: types.Selector<TSelector>, options?: types.WaitOptions): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    execute(script: ((args: any) => any) | string, arg?: any): Promise<any>;
    getContextElement(): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    getScrollingElement(): Promise<Element<TDriver, TContext, TElement, TSelector>>;
    setScrollingElement(scrollingElement: Element<TDriver, TContext, TElement, TSelector> | TElement | types.Selector<TSelector>): Promise<void>;
    blurElement(element?: Element<TDriver, TContext, TElement, TSelector>): Promise<TElement>;
    focusElement(element: Element<TDriver, TContext, TElement, TSelector>): Promise<any>;
    getRegion(): Promise<types.Region>;
    getClientRegion(): Promise<types.Region>;
    getScrollingRegion(): Promise<types.Region>;
    getContentSize(): Promise<types.Size>;
    getInnerOffset(): Promise<types.Location>;
    getLocationInMainContext(): Promise<types.Location>;
    getLocationInViewport(): Promise<types.Location>;
    getRegionInViewport(region: types.Region): Promise<types.Region>;
    getCookies(): Promise<types.Cookie[]>;
    private preserveInnerOffset;
    private preserveContextRegions;
    private preserveScrollingRegion;
}
